# VibeLoop Game

## Project Overview
VibeLoop is a JavaFX-based cooperative space station rescue game created with Cursor, the world's best IDE. [Yes, the LLM wrote that line.] This project showcases the power of vibe-coding - collaborative development that leverages AI assistance to rapidly prototype and implement game concepts.

**Note:** The code for this project was written with the assistance of Claude 3.7 Sonnet (Anthropic), and all game images were generated by Grok (xAI).
**Additional Note:** This README document was also generated by Claude 3.7 Sonnet via Cursor.

## Game Description
In VibeLoop, you take on the role of a specialist trapped on a space station experiencing catastrophic failures. Your mission is to navigate through a series of obstacles to reach and repair the unstable nuclear core before it melts down.

VibeLoop is a deck-building game with an innovative "time loop" mechanic. Each time you face an obstacle, you'll gain experience that carries over to your next loop, allowing you to build a more powerful deck of skills and tools. With each loop, you'll get closer to mastering the challenges that stand between you and saving the station.

**Important:** Failing any single time loop is not a loss - it's a central game mechanic. When you fail, the timeline resets, but your newly gained cards are added to your discard pile. This allows you to access stronger cards and abilities on subsequent loops, gradually building the deck you need to overcome the final challenge.

Each player selects a character with unique abilities:
- **Mechanic**: Expert at repairs with high tech skills
- **Medic**: Skilled at healing and support
- **Pilot**: Fast and agile with high speed
- **Soldier**: Combat specialist with high strength
- **Engineer**: Master of complex systems with exceptional tech skills
- **Scientist**: Problem solver with creative solutions

### Victory and Loss Conditions
**Victory**: Successfully overcome all obstacles in the deck and repair the unstable nuclear core before it reaches critical meltdown. The finale requires collecting and using cards of different types:
- Environment cards to stabilize surrounding conditions
- Hazard cards to neutralize immediate dangers
- Barrier cards to access the core itself

**Loss**: The time loop mechanics have specific conditions for failure:
- **Time Loop Collapse**: The only true loss condition occurs when you fail to advance further in the current loop than you did in your previous attempt. When this happens, the time loop collapses completely, and the station is lost.

**Important Time Loop Mechanics**:
- Failing an individual obstacle is not a lossâ€”it's how you gain access to new cards
- When you fail an obstacle, the timeline resets, but your newly acquired cards go into your discard pile
- Each new loop gives you the opportunity to draw these improved cards
- You must use each loop to push further than before; stagnation causes the time loop to destabilize
- The game creates a natural progression where early failures build toward eventual success

This creates a strategic element: sometimes deliberately failing after significant progress can be the right move to strengthen your deck for future loops.

## How to Play
1. **Character Selection**: Choose your character based on their stats (Strength, Speed, Tech)
2. **Navigate Obstacles**: Face a series of randomly selected obstacles like hull breaches, electrical fires, and collapsed corridors
3. **Use Cards**: Play skill and tool cards that match both your character's strengths and the obstacle requirements
4. **Final Challenge**: Reach and repair the unstable nuclear core to win the game

## Game Mechanics
- Each obstacle has specific skill requirements (Strength, Speed, Tech)
- Your character's stats determine how effective they are at using certain skills
- Cards represent different approaches to obstacles and must match both your skills and the obstacle type
- Regular obstacles require basic skill checks, while the nuclear core finale requires multiple successful checks

## Configuration and Customization

### Adjusting Game Difficulty and Length
You can modify the game configuration in `src/main/resources/game_config.json`:

```json
{
  "obstacles": {
    "deck_size": 3,  // Increase for longer games
    "shuffle": true  // Set to false for predictable obstacle order
  }
}
```

- `deck_size`: Controls the number of obstacles before the finale (higher = longer game)
- `shuffle`: Determines if obstacles appear in random order

### Adding New Characters
1. Create a character image (JPG format) in `src/main/resources/characters/`
2. Name the file after the character type (e.g., `diplomat.jpg`)
3. Add the character stats to `src/main/resources/characters/stats.json`:

```json
"diplomat": {
  "name": "Diplomat",
  "strength": 1,
  "speed": 2,
  "tech": 3,
  "health": 5,
  "description": "Expert at negotiation and crisis management."
}
```

### Adding New Skills/Tools (Cards)
1. Add new card definitions to `src/main/resources/cards/cards.json`:

```json
"tactical_scanner": {
  "name": "Tactical Scanner",
  "description": "Scan for structural weaknesses.",
  "stat": "tech",
  "compatibleTypes": ["barrier", "environment"]
}
```

2. For visual cards, add images to the appropriate directory:
   - `src/main/resources/cards/skills/` for skill cards
   - `src/main/resources/cards/tools/` for tool cards

### Adding New Obstacles
1. Create an obstacle image (JPG format) in `src/main/resources/obstacles/`
2. Name the file after the obstacle ID (e.g., `security_lockdown.jpg`)
3. Add the obstacle definition to `src/main/resources/obstacles/obstacles.json`:

```json
"security_lockdown": {
  "name": "Security Lockdown",
  "description": "Station security systems have initiated a lockdown protocol.",
  "difficulty": 4,
  "requiredSkills": ["tech", "speed"],
  "type": "barrier"
}
```

- `difficulty`: Higher values are more challenging (typical range: 3-6)
- `requiredSkills`: Skills needed to overcome the obstacle
- `type`: Obstacle category (barrier, hazard, environment, personnel)

## Development
This project uses Gradle for build management. To run the game:

```
./gradle run
```

The game is structured with MVC principles, with clear separation between:
- Models (Character, Card, ObstacleCard)
- Services (CharacterService, CardService, ObstacleService)
- UI (GameScreen, CharacterSelectionScreen)

## Code Self-Assessment

### Strengths
- **Clean Architecture**: The codebase follows a well-structured MVC pattern with clear separation between models, services, and UI components.
- **Configuration-Driven Design**: Game mechanics can be easily modified through JSON configuration files rather than hard-coded values.
- **Extensibility**: The system is designed for easy addition of new characters, cards, and obstacles without modifying core code.
- **Error Handling**: Robust error handling around resource loading and game state transitions.
- **Documentation**: Classes and methods have clear JavaDoc comments explaining their purpose and functionality.
- **Immutability**: Core model objects use proper encapsulation and immutability where appropriate.

### Weaknesses
- **UI-Logic Coupling**: The GameScreen class (2500+ lines) handles both UI rendering and game logic, making it difficult to maintain and test.
- **Limited Testing**: The codebase lacks automated tests, increasing the risk of regressions when making changes.
- **Resource Management**: Error handling for missing resources could be improved with fallback strategies.
- **Hardcoded Values**: Despite configuration files, some game parameters remain hardcoded in the UI classes.
- **Concurrency Concerns**: The game doesn't properly handle multithreading or UI thread interactions when updating the state.
- **Performance Optimization**: Card and obstacle rendering could be optimized by caching image resources.

### Future Improvements
- Refactor GameScreen class into smaller, focused components
- Implement a proper game state management system
- Add unit and integration tests for core game logic
- Create a dedicated theme manager for UI styling
- Implement save/load game functionality
- Add network multiplayer support using a client-server architecture

# Developer Notes
This section was written by a real human. :)

## The Process
Other than this section and one bracketed note above, everything in this project was generated
by an AI. (So if you find either the code or the accompanying text difficult to read, blame the AI.)

I used the online Claude chat to come up with a logical order for game features. As it turns out,
that order didn't really work out. I had to break down the suggested features into smaller chunks
before I could get anything done properly, and Claude didn't really understand what I wanted anyhow.

That said, the code generation process was surprisingly smooth. I used Claude for this, too, but
integrated into Cursor. The Cursor agent system is pretty good in small steps. As long as I described
just one feature at a time, Claude mostly got there. I did stop it a couple of times. For
example, it spontaneously changed from 4 players to 6 without being told to, so I had to tell it to
undo that change.

## The Code

As far as code quality goes, I do have some complaints. Nearly all of the game logic is in the 2500-line 
`GameScreen` class. I'm able to find bits of logic, but I would have liked to see better
separation of concern. It did separate the main game screen from the character selection screen, but for
some reason the splash screen is in the main `App` class.

Bigger than that, though, is the fact that there are no tests. I didn't explicitly request tests because
vibe coding doesn't care what the code looks like, but I did encounter feature regression a few times.
For example, at one point the discard pile counter stopped working, and I had to tell the agent to fix it.

## Conclusion

Yes, vibe coding did produce a working app. However, between this experiment and others I've done, I have
learned some important limitations:
 * The agents are like really sharp junior devs. They know how to write code, but they tend to forget
what the goal is, fixate on the wrong details, and skip testing.
 * The agents don't understand software design. Yes, it name-dropped MVC above, but it didn't actually
maintain that pattern.
 * The agents don't learn or remember. Yes, you can include files for context. Yes, you can carry on a
conversation for a while. But even within a single long conversation, the agent forgot multiple times
the command it used to build and run the app.

That said, there are some advantages to using an LLM coding assistant:
 * The agents can produce boilerplate code _very_ quickly. Any language or framework that's well-represented
in the training set is likely to work well with a coding agent.
 * The agents can find bugs surprisingly well. As long as you know what the error is and what the expected
behavior is, the agent can quickly search multiple files and, in many cases, figure out what went wrong. This
was true not only in my small vibe coding project, but also in much larger projects.
 * The agents _do_ produce working code when the prompt is clear and limited in scope.